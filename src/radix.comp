#version 450

#define THREADS 64 
#define LOCAL_SORT_THRESHOLD 8192
// 9216 (64*144) 

#define BITONIC_SIZE 1024 
#define BITONIC_KPT 4 // keys per thread. 

#define VERY_BIG_NUMBER 0xffffffff
 // should inf be used instead? 

layout(local_size_x = THREADS) in;

struct KeyBlock {
	uint key_offset;
	uint key_count;
	uint buffer_id;
	uint buffer_offset;
};

struct LocalSortBlock {
	uint buffer_id;
	uint buffer_offset;
	uint is_merged;
};

/***************************************************************************************/

//// Parameters that stay constants in kernel launch.
//layout(set = 0, binding = 0) uniform RadixSortParams {
//    vec4 blah;		
//} params;
//
//layout(set = 1, binding = 0) buffer Current {
//    RayOutput[] ray_output;
//};
//
//layout(set = 2, binding = 0) buffer Swap {
//    uint[] frame_output;
//};

/***************************************************************************************/

// Exctract 8 bytes from 32 bit unsigned integer.
// @key is the key.
// @amount is the bitshift to the left.
// @return Extracted 8 bytes as unsigned integer.
uint extract_digit_msd(uint key, int amount) {
	return (key & (0xff000000 >> amount)) >> (24 - amount);
}

/***************************************************************************************/

// Bitonic sort.
//void bitonic(int j, int k) {
//  uint output_index =
//    (gl_GlobalInvocationID.x ) +
//    gl_NumWorkGroups.x * gl_WorkGroupSize.x * (gl_GlobalInvocationID.y) + 
//    gl_NumWorkGroups.x * gl_WorkGroupSize.x * gl_NumWorkGroups.y * gl_WorkGroupSize.y * (gl_GlobalInvocationID.z);
//
//        shared int temp[BITONIC_SIZE];
//	const local_id_x = gl_LocalInvocationID.x; 
//	const local_size = gl_WorkGroupSize.x;
//
//	for (int i=0 ; i<BITONIC_KPT; i++) {
//		int i = local_id
//	}
//
//
//
//	const uint i = gl_GlobalInvocationID.x;
//        const uint ixj = i^j; 
//	if ((ixj)>i) {
//		if ((i&k) == 0) {
//			if (values[i] > values[ixj] { // swap values.
//				float temp = dev_values[i];
//				values[i] = values[ixj];
//                                values[ixj] = temp;
//			}
//		}
//	}
//	if ((i&k) != 0) {
//		if (values[i] < values[ixj]) {
//			float temp = dev_values[i];
//			values[i] = values[ixj];
//                        values[ixj] = temp;
//		
//		}
//	}
//}
//

void main() {

}
