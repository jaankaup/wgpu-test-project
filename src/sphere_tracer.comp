#version 450

#define STEP_SIZE 2.0

//__constant sampler_t sampler = CLK_NORMALIZED_COORDS_TRUE | CLK_ADDRESS_REPEAT | CLK_FILTER_LINEAR;

#define LOCAL_X_DIM 8 
#define LOCAL_Y_DIM 8

layout(local_size_x = LOCAL_X_DIM, local_size_y = LOCAL_Y_DIM) in;

struct RayOutput {
    vec4 origin; // fourth element == visibility.
    vec4 intersection_point; // fourt element == opacity.
    vec4 normal; // fourth element == the diffuse color.
};

struct Ray {
  vec3 origin;
  vec3 direction;
  float rMin;
  float rMax;
};

struct RayPayload {
  vec4 intersection_point;
  vec4 normal;
  float visibility;
  float opacity;
  uint color;
};

layout(set = 0, binding = 0) uniform RayCamera {
    vec4 position;		
    vec4 view;			
    vec4 up;			
    vec4 fov;		
    float apertureRadius;
    float focalDistance;
} camera;

layout(set = 1, binding = 0) uniform texture2D t_diffuse1; // grass
layout(set = 1, binding = 1) uniform sampler s_diffuse1;
layout(set = 1, binding = 2) uniform texture2D t_diffuse2; // rock
layout(set = 1, binding = 3) uniform sampler s_diffuse2;

layout(set = 2, binding = 0) writeonly buffer RayOutputBuffer {
    RayOutput[] ray_output;
};

layout(set = 3, binding = 0) buffer Prkl {
    uint[] frame_output;
};

// Noise functions copied from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83.

//	<https://www.shadertoy.com/view/4dS3Wd>
//	By Morgan McGuire @morgan3d, http://graphicscodex.com
//
float hash(float n) { return fract(sin(n) * 1e4); }
float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }

float noise(float x) {
	float i = floor(x);
	float f = fract(x);
	float u = f * f * (3.0 - 2.0 * f);
	return mix(hash(i), hash(i + 1.0), u);
}

float noise(vec2 x) {
	vec2 i = floor(x);
	vec2 f = fract(x);

	// Four corners in 2D of a tile
	float a = hash(i);
	float b = hash(i + vec2(1.0, 0.0));
	float c = hash(i + vec2(0.0, 1.0));
	float d = hash(i + vec2(1.0, 1.0));

	// Simple 2D lerp using smoothstep envelope between the values.
	// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),
	//			mix(c, d, smoothstep(0.0, 1.0, f.x)),
	//			smoothstep(0.0, 1.0, f.y)));

	// Same code, with the clamps in smoothstep and common subexpressions
	// optimized away.
	vec2 u = f * f * (3.0 - 2.0 * f);
	return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

// This one has non-ideal tiling properties that I'm still tuning
float noise(vec3 x) {
	const vec3 step = vec3(110, 241, 171);

	vec3 i = floor(x);
	vec3 f = fract(x);

	// For performance, compute the base input to a 1D hash from the integer part of the argument and the
	// incremental change to the 1D based on the 3D -> 1D wrapping
    float n = dot(i, step);

	vec3 u = f * f * (3.0 - 2.0 * f);
	return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),
                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),
                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
}

#define NUM_OCTAVES 5

float fbm(float x) {
	float v = 0.0;
	float a = 0.5;
	float shift = float(100);
	for (int i = 0; i < NUM_OCTAVES; ++i) {
		v += a * noise(x);
		x = x * 2.0 + shift;
		a *= 0.5;
	}
	return v;
}

float fbm(vec2 x) {
	float v = 0.0;
	float a = 0.5;
	vec2 shift = vec2(100);
	// Rotate to reduce axial bias
    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
	for (int i = 0; i < NUM_OCTAVES; ++i) {
		v += a * noise(x);
		x = rot * x * 2.0 + shift;
		a *= 0.5;
	}
	return v;
}


float fbm(vec3 x) {
	float v = 0.0;
	float a = 0.5;
	vec3 shift = vec3(100);
	for (int i = 0; i < NUM_OCTAVES; ++i) {
		v += a * noise(x);
		x = x * 2.0 + shift;
		a *= 0.5;
	}
	return v;
}


/******************************************************************************************************************************/

uint encode_color(vec4 color) {

  return ((uint(color.w * 255) & 0xffff) << 24) | // alpha
         ((uint(color.z * 255) & 0xffff) << 16) | // blue
         ((uint(color.y * 255) & 0xffff) << 8 ) | // green
         (uint(color.x * 255) & 0xffff);          // red 
}

/******************************************************************************************************************************/
// Calculate the density value.
float calculate_density(vec3 f_pos) {
  float n = noise(f_pos * 0.1);
  float n2 = fbm(f_pos * 0.01);
  return f_pos.y + 5*n + 180*n2; 
}

 /******************************************************************************************************************************/
 
// Calculate the fog value.
float fog(vec3 fogPos)
{
  return fogPos.x; // dummy value
}

/******************************************************************************************************************************/

vec3 calculate_normal(vec3 pos)
{
  vec3 grad;

  const float offset = 0.01f;
  float right =   calculate_density(vec3(pos.x+offset, pos.y,pos.z));
  float left =    calculate_density(vec3(pos.x-offset, pos.y,pos.z));
  float up =      calculate_density(vec3(pos.x, pos.y+offset,pos.z));
  float down =    calculate_density(vec3(pos.x, pos.y-offset,pos.z));
  float z_minus = calculate_density(vec3(pos.x, pos.y,pos.z-offset));
  float z = 	  calculate_density(vec3(pos.x, pos.y,pos.z+offset));
  grad.x = right - left;
  grad.y = up - down;
  grad.z = z - z_minus;
  return normalize(grad);
}

/******************************************************************************************************************************/

// Calculate the normal and the sampled value.
// Return a vector where vec4(normal_vector :: vec3, sampled_value :: float);
vec4 calculate_normal2(vec3 pos) {
  vec3 grad;

  float sp = calculate_density(pos); // sp == sample

  const float offset = 0.025f;
  float right =   calculate_density(vec3(pos.x+offset, pos.y,pos.z));
  float left =    calculate_density(vec3(pos.x-offset, pos.y,pos.z));
  float up =      calculate_density(vec3(pos.x, pos.y+offset,pos.z));
  float down =    calculate_density(vec3(pos.x, pos.y-offset,pos.z));
  float z =       calculate_density(vec3(pos.x, pos.y,pos.z-offset));
  float z_minus = calculate_density(vec3(pos.x, pos.y,pos.z+offset));

  vec3 sample0 = vec3(left,down,z);
  vec3 sample1 = vec3(right,up,z_minus);

  vec3 scaledPosition = pos * offset - 0.5f;
  vec3 fraction = scaledPosition - floor(scaledPosition);
  vec3 correctionPolynomial = (fraction * (fraction - 1.0f)) * 0.5f;

  sp += dot((sample0 - sp * 2.0f + sample1), correctionPolynomial);
  return vec4(normalize(sample1 - sample0), sp);
}

/******************************************************************************************************************************/

// Calculate the point in the Ray direction.
vec3 getPoint(float parameter, in Ray ray)
{
  return ray.origin + parameter * ray.direction; 
}

/******************************************************************************************************************************/

// If ray does not intersect anything (back groung color).
void miss(in Ray ray, inout RayPayload payload) {

  vec3 far_point = getPoint(ray.rMax,ray);

  // SKY
  // float value_x = noise(far_point.x*0.008);
  // float value_y = noise(far_point.y*0.008);
  float value_z = noise(far_point.z*0.008);

  float value_cloud_x = noise(vec3(far_point.x*0.004, far_point.y*0.004, far_point.z*0.004f));
  float value_cloud_y = noise(vec3(far_point.x*0.004, far_point.y*0.004, far_point.z*0.004f));
  float value_cloud_z = noise(vec3(far_point.x*0.004, far_point.y*0.004, far_point.z*0.004f));

  float red = max(0.0f,-far_point.y/80.0f + 0.5f);
  float blue = max(0.2f,(value_cloud_z * 0.8f + value_z*far_point.y) * 0.5f); 
  float cloud = (value_cloud_x + value_cloud_y + value_cloud_z) / 12.0;

  vec4 sky_color = vec4(red * 1.0, 0.1 + cloud, 0.1 + cloud, 1.0); 

  const float light_opacity = 0.9;
  vec4 color = vec4(mix(sky_color.xyz, vec3(0.1f,0.1f,0.1f), min(0.9f,light_opacity)), 1.0); 
  vec4 final_color = vec4( 
	min(1.0f,color.x + light_opacity*0.1f),
	min(1.0f,color.y + light_opacity*0.1f),
	min(1.0f,color.z + light_opacity*0.1f),
        1.0);
  payload.color = encode_color(final_color);
}

/******************************************************************************************************************************/

// Calculate the phong-shading for the intersection point. Saves color and normal to the payload.
void diffuse(in Ray ray, inout RayPayload payload) {
  // TODO: do uniform.
  const vec3 light_color = vec3(1.0f,1.0f,0.8f);
  const float ambientCoeffience = 0.15f;
  const float attentuationFactor = 0.00009f;
  const float materialShininess = 170.0f;

  const vec2 coord1 = payload.intersection_point.xy;
  const vec2 coord2 = payload.intersection_point.xz;
  const vec2 coord3 = payload.intersection_point.zz;

  const vec3 surfaceColor_grass = texture(sampler2D(t_diffuse1, s_diffuse1), (coord1 + coord2 + coord3) / 3.0).xyz;
  const vec3 surfaceColor_rock = texture(sampler2D(t_diffuse2, s_diffuse2), (0.1 *( coord1 + coord2 + coord3) / 3.0f)).xyz;

  const vec3 surface_color = mix(surfaceColor_rock, surfaceColor_grass, clamp(0.4 * payload.normal.x + 0.6 * payload.normal.y, 0.0, 1.0)); 

  const float distToLight = length(camera.position.xyz - payload.intersection_point.xyz);
  const vec3 dirToLight = normalize(camera.position.xyz - payload.intersection_point.xyz);
  const float diffuseCoeffient = max(0.0f,dot(payload.normal.xyz, dirToLight)); 
  const vec3 incidenceVector = -dirToLight;
  const vec3 reflectionVector = incidenceVector - 2.0 * dot(payload.normal.xyz, incidenceVector) * payload.normal.xyz;
  const float cosAngle = max(0.0f, dot(ray.direction, reflectionVector));

  float specularCoeffient = 0.0;
  if (diffuseCoeffient > 0.0) specularCoeffient = pow(cosAngle, materialShininess);

  vec3 specularComponent = specularCoeffient * surface_color * light_color;

  vec3 ambient = ambientCoeffience * light_color * surface_color;
  vec3 diffuseComponent = diffuseCoeffient * light_color * surface_color;
  float attentuation = 1.0 / (1.0 + attentuationFactor * pow(distToLight,2.0));
  payload.color = encode_color(
  	vec4 (ambient + attentuation * (2.0f * (diffuseComponent + specularComponent)), 1.0)
  );
}

/******************************************************************************************************************************/

void shootShadowRay(in Ray ray, in RayPayload payload)
{
  float dist = ray.rMin;
  vec3 p;
  float value_calculate_density;

   while (dist < ray.rMax) {
     p = getPoint(dist, ray); 
     value_calculate_density = calculate_density(p);
     if (value_calculate_density < 0.0f) {
       //payload.visibility = min(0.8f, payload.opacity);
       return;
     }
     dist += 1.0f;
   }
}

/******************************************************************************************************************************/

void hit(in Ray ray, inout RayPayload payload) {


  vec4 normal = calculate_normal2(payload.intersection_point.xyz);

  // TODO: Add light_position to uniform.
  vec3 light_position = camera.position.xyz;

  // TODO: Handle shadow ray lates.
  // Ray shadowRay;
  // shadowRay.origin = getPoint(temp_distance - STEP_SIZE, ray);  
  // shadowRay.direction = normalize(light_position - p); 
  // shadowRay.rMin = 0.0f; 
  // shadowRay.rMax = length(light_position - shadowRay.origin); 

  // RayPayload shadowPayload;
  // shadowPayload.visibility = 1.0f;
  // shadowPayload.opacity = 0.9f*payload.opacity;
  // 
  // shootShadowRay(shadowRay, shadowPayload);

  payload.normal = normal;

  // Calculate color. Add the color and normal to the payload.
  diffuse(ray, payload);
  // payload.color.x = min(1.0f,color.x); // + light_opacity);
  // payload.color.y = min(1.0f,color.y); // + light_opacity);
  // payload.color.z = min(1.0f,color.z); // + light_opacity);
  // payload.color.w = 1.0f; 
// KESKEN
}

/******************************************************************************************************************************/

// Trace a ray.  
void traceRay(inout Ray ray, inout RayPayload payload) {
  float dist = ray.rMin;
  float maxi = ray.rMax;
  vec3 p;
  float value_calculate_density;
  // float dist = 0.0;

   while (dist < ray.rMax) { 
     p = getPoint(dist, ray); 
     value_calculate_density = calculate_density(p);
     if (value_calculate_density < 0.0) {

	// Check for more detailed intersection point.
        // TODO: is this necessery?

	// Step backward the ray.
  	float temp_distance = dist - STEP_SIZE;
  	float value;
  	vec3 p; 

	// Calculate more accurate intersection point.
  	while (temp_distance < dist) {
  	  p = getPoint(temp_distance, ray); 
  	  value = calculate_density(p);
  	  if (value < 0.0) break;
  	  temp_distance += 0.1;
  	}
	
	// Jump back a litte.
	temp_distance -= 0.1;

	// Save intersection point.
	payload.intersection_point = vec4(getPoint(temp_distance, ray) , 1.0);

	// Calculate normal and the actual value. payload.normal == vec3(normal, value);
        payload.normal = calculate_normal2(payload.intersection_point.xyz);

       // Calculate the color and the normal for intersection.
       payload.intersection_point = vec4(p, 1.0); // TODO: check the final point here.
       hit(ray,payload);
       return;
     }
     dist += STEP_SIZE;
   }
   payload.intersection_point = vec4(p, 1.0); // TODO: check the final point here.
   miss(ray,payload);
}

/******************************************************************************************************************************/


void main () {

  float x_coord = float(gl_GlobalInvocationID.x);
  float y_coord = float(gl_GlobalInvocationID.y);
  float global_x_dim = float(gl_NumWorkGroups.x * LOCAL_X_DIM);
  float global_y_dim = float(gl_NumWorkGroups.y * LOCAL_Y_DIM);

  vec3 right = normalize(cross(camera.view.xyz,camera.up.xyz));  
  vec3 y = normalize(cross(camera.view.xyz, right));

  float d = camera.focalDistance;  
  
  vec3 u = (d * tan(camera.fov.x*0.5)) * right; 
  vec3 v = (d * tan(camera.fov.y*0.5)) * y;

  float alpha = 2.0 * (x_coord + 0.5f) / global_x_dim - 1.0;
  float beta  = 1.0 - 2.0f * (y_coord + 0.5f) / global_y_dim;

  vec3 point_on_plane = alpha * u + beta * v;

  Ray ray;
  ray.origin = point_on_plane + camera.position.xyz;
  ray.direction = normalize(point_on_plane + d*camera.view.xyz);
  ray.rMin = 0.0f;
  ray.rMax = 600.0f;
  
  RayPayload payload;
  payload.color = encode_color(vec4(1.0f,0.0f,0.0f,1.0f));

  traceRay(ray, payload); 

  RayOutput result;
  result.origin = vec4(ray.origin, 1.0);
  result.intersection_point = payload.intersection_point; 
  result.normal = payload.normal;

// struct RayOutput {
//     vec4 origin; // fourth element == visibility.
//     vec4 intersection_point; // fourt element == opacity.
//     vec4 normal; // fourth element == the diffuse color.
// };

  ray_output[gl_GlobalInvocationID.x + gl_NumWorkGroups.x * gl_WorkGroupSize.x * gl_GlobalInvocationID.y] = result;
  frame_output[gl_GlobalInvocationID.x + gl_NumWorkGroups.x * gl_WorkGroupSize.x * gl_GlobalInvocationID.y] = payload.color;
  //frame_output[gl_GlobalInvocationID.x + gl_NumWorkGroups.x * gl_WorkGroupSize.x * gl_GlobalInvocationID.y] = converted_color_rgba;

  // debug_output[gl_GlobalInvocationID.x + gl_NumWorkGroups.x *
  // gl_WorkGroupSize.x * gl_GlobalInvocationID.y] = vec4(camera.apertureRadius,
  // camera.focalDistance, 12.0, 13.0 );

}
