#version 450

#define LOCAL_X_DIM 32 
#define LOCAL_Y_DIM 1

layout(local_size_x = LOCAL_X_DIM, local_size_y = LOCAL_Y_DIM) in;

//struct Vertex {
//    vec4 v;
//    vec4 n;
//};
//
//struct Ray {
//    vec3 origin;
//    vec3 direction;
//};

//layout(set = 0, binding = 0) uniform RayCamera {
//    vec3 position;		
//    vec3 view;			
//    vec3 up;			
//    vec2 fov;		
//    float apertureRadius;
//    float focalDistance;
//} camera;
//
//// TODO: later
//layout(set = 1, binding = 0) uniform texture2D t_diffuse;
//layout(set = 1, binding = 1) uniform sampler s_diffuse;

layout(set = 0, binding = 0) buffer Prkl {
    uint[] frame_output;
};

//float maasto(vec3 f_pos) {
//    return f_pos.y;
//}
//
//vec3 getPoint(float distance, in Ray ray) {
//    return ray.origin + distance * ray.direction;
//}

void main() {	

  uint pos_x = gl_GlobalInvocationID.x;
  uint pos_y = gl_GlobalInvocationID.y;
  uint pos_z = gl_GlobalInvocationID.z;

  //float x_coord = float(gl_GlobalInvocationID.x);
  //float y_coord = float(gl_GlobalInvocationID.y);
  //float global_x_dim = float(gl_NumWorkGroups.x * LOCAL_X_DIM);
  //float global_y_dim = float(gl_NumWorkGroups.y * LOCAL_Y_DIM);

  //vec3 right = normalize(cross(camera.view,camera.up));  
  //vec3 y = normalize(cross(camera.view, right));

  //float d = camera.focalDistance;  
  //
  //vec3 u = (d * tan(camera.fov.x*0.5f)) * right; 
  //vec3 v = (d * tan(camera.fov.y*0.5f)) * y;

  //float alpha = 2.0 * (x_coord + 0.5f) / global_x_dim - 1.0;
  //float beta  = 1.0 - 2.0f * (y_coord + 0.5f) / global_y_dim;

  //vec3 point_on_plane = alpha * u + beta * v;

  //Ray ray;
  //ray.origin = point_on_plane + camera.position; //(float3){0.0f, 0.0f, 1.0f}; // + cam->view*d; //point_on_plane; //-d*cam->view; // point_on_plane; // cam->position; 
  //ray.direction = normalize(point_on_plane + d*camera.view);

  //vec3 intersection_point = camera.position; // (float3){0.0,0.0,0.0};
  ////float3 normal = (float3){0.0,0.0,0.0};
  //vec3 accum_color = vec3(0.0f, 0.0f, 0.0f);

  //const float step_size = 2.0f;
  //float depth = 0.0f;
  //const float max_depth = 330.0f;
  ////float3 light_direction = (float3){0.0,1.0,0.0};
  //float last_value = maasto(ray.origin);

  //for (int i=0 ; i<600 ; i++)
  //{
  //  vec3 p = getPoint(depth, ray);
  //  float value_maasto = maasto(p);

  //  if (p.y > 80.0 || p.y < -100.0) break;

  //  if (value_maasto < 0.0f) {
  //    depth -= step_size;
  //    float temp_depth = depth - step_size;
  //    for (int k=0; k<16 ; k++) {
  //      temp_depth = depth + float(k) * (step_size / 15.0);
  //      p = getPoint(temp_depth, ray);
  //      value_maasto = maasto(p);
  //      if (value_maasto < 0.0f) { intersection_point = p; depth = temp_depth; break; }
  //    } // for
  //    break;
  //  } // if

  //  float diff = value_maasto - last_value;
  //  depth += max(step_size, step_size + 0.5f * diff);
  //  last_value = value_maasto;

  //  if (depth > max_depth) break;
  //} // for
  vec4 final_color = vec4(1.0,1.0,1.0,1.0); //texture(sampler2D(t_diffuse, s_diffuse), intersection_point.xy) ;
  //uint converted_color_rgba = 0 | uint(final_color.x * 255) << 24 |

  // WORKS!
  //uint converted_color_rgba = ((uint(1.0 * 255) & 0xffff) << 24) | // alpha
  //                            ((uint(0.0 * 255) & 0xffff) << 16) | // blue
  //                            ((uint(0.0 * 255) & 0xffff) << 8 ) | // green
  //                            (uint(1.0 * 255) & 0xffff);          // red 

  uint converted_color_rgba = ((uint(final_color.w * 255) & 0xffff) << 24) | // alpha
                              ((uint(final_color.z * 255) & 0xffff) << 16) | // blue
                              ((uint(final_color.y * 255) & 0xffff) << 8 ) | // green
                              (uint(final_color.x * 255) & 0xffff);          // red 

  //  //const uint save_position = gl_GlobalInvocationID.y * gl_WorkGroupSize.x + gl_GlobalInvocationID.x;  
  //screen.frame_output[gl_LocalInvocationIndex] = converted_color_rgba;

  // TOIMIII!!!
  //frame_output[gl_GlobalInvocationID.x + gl_NumWorkGroups.x * gl_WorkGroupSize.x * gl_GlobalInvocationID.y] = 0 | gl_GlobalInvocationID.x << 16 | gl_GlobalInvocationID.y;
  frame_output[gl_GlobalInvocationID.x + gl_NumWorkGroups.x * gl_WorkGroupSize.x * gl_GlobalInvocationID.y] = converted_color_rgba;

  // THiS WORKS 1-d!
  //frame_output[gl_GlobalInvocationID.x] =  gl_GlobalInvocationID.x; //converted_color_rgba;  

}
